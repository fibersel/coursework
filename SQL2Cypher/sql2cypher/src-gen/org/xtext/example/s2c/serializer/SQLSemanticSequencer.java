/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.s2c.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.s2c.sQL.Binary;
import org.xtext.example.s2c.sQL.Column;
import org.xtext.example.s2c.sQL.Factor;
import org.xtext.example.s2c.sQL.Model;
import org.xtext.example.s2c.sQL.SQLPackage;
import org.xtext.example.s2c.sQL.Term;
import org.xtext.example.s2c.sQL.boolExpression;
import org.xtext.example.s2c.sQL.expression;
import org.xtext.example.s2c.sQL.fromItem;
import org.xtext.example.s2c.sQL.fromSection;
import org.xtext.example.s2c.sQL.group_clause;
import org.xtext.example.s2c.sQL.having_clause;
import org.xtext.example.s2c.sQL.select;
import org.xtext.example.s2c.sQL.where_clause;
import org.xtext.example.s2c.services.SQLGrammarAccess;

@SuppressWarnings("all")
public class SQLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SQLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SQLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SQLPackage.BINARY:
				sequence_Binary(context, (Binary) semanticObject); 
				return; 
			case SQLPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case SQLPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case SQLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SQLPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case SQLPackage.BOOL_EXPRESSION:
				sequence_boolExpression(context, (boolExpression) semanticObject); 
				return; 
			case SQLPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case SQLPackage.FROM_ITEM:
				sequence_fromItem(context, (fromItem) semanticObject); 
				return; 
			case SQLPackage.FROM_SECTION:
				sequence_fromSection(context, (fromSection) semanticObject); 
				return; 
			case SQLPackage.GROUP_CLAUSE:
				sequence_group_clause(context, (group_clause) semanticObject); 
				return; 
			case SQLPackage.HAVING_CLAUSE:
				sequence_having_clause(context, (having_clause) semanticObject); 
				return; 
			case SQLPackage.SELECT:
				sequence_select(context, (select) semanticObject); 
				return; 
			case SQLPackage.WHERE_CLAUSE:
				sequence_where_clause(context, (where_clause) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Binary returns Binary
	 *
	 * Constraint:
	 *     (lhs=Column rhs=Column)
	 */
	protected void sequence_Binary(ISerializationContext context, Binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SQLPackage.Literals.BINARY__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQLPackage.Literals.BINARY__LHS));
			if (transientValues.isValueTransient(semanticObject, SQLPackage.Literals.BINARY__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQLPackage.Literals.BINARY__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryAccess().getLhsColumnParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBinaryAccess().getRhsColumnParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SQLPackage.Literals.COLUMN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQLPackage.Literals.COLUMN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     (factor=Factor | expr=boolExpression | binexp=Binary)
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     statements+=select
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Term
	 *
	 * Constraint:
	 *     (lhs=Factor rhs=Factor)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SQLPackage.Literals.TERM__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQLPackage.Literals.TERM__LHS));
			if (transientValues.isValueTransient(semanticObject, SQLPackage.Literals.TERM__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQLPackage.Literals.TERM__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermAccess().getLhsFactorParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getTermAccess().getRhsFactorParserRuleCall_1_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     boolExpression returns boolExpression
	 *
	 * Constraint:
	 *     (lhs=Term rhs=Term?)
	 */
	protected void sequence_boolExpression(ISerializationContext context, boolExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (col=Column | col=Column)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fromItem returns fromItem
	 *
	 * Constraint:
	 *     ((table_name=ID | select_expr=select) (rhs=fromItem bool_expr=boolExpression)?)
	 */
	protected void sequence_fromItem(ISerializationContext context, fromItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fromSection returns fromSection
	 *
	 * Constraint:
	 *     from_item=fromItem
	 */
	protected void sequence_fromSection(ISerializationContext context, fromSection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SQLPackage.Literals.FROM_SECTION__FROM_ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQLPackage.Literals.FROM_SECTION__FROM_ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFromSectionAccess().getFrom_itemFromItemParserRuleCall_1_0(), semanticObject.getFrom_item());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     group_clause returns group_clause
	 *
	 * Constraint:
	 *     (expressions+=expression expressions+=expression*)
	 */
	protected void sequence_group_clause(ISerializationContext context, group_clause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     having_clause returns having_clause
	 *
	 * Constraint:
	 *     expr=boolExpression
	 */
	protected void sequence_having_clause(ISerializationContext context, having_clause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SQLPackage.Literals.HAVING_CLAUSE__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQLPackage.Literals.HAVING_CLAUSE__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHaving_clauseAccess().getExprBoolExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     select returns select
	 *
	 * Constraint:
	 *     (
	 *         expressions+=expression 
	 *         expressions+=expression* 
	 *         from_section=fromSection? 
	 *         where_section=where_clause? 
	 *         group_section=group_clause? 
	 *         having_section=having_clause?
	 *     )
	 */
	protected void sequence_select(ISerializationContext context, select semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     where_clause returns where_clause
	 *
	 * Constraint:
	 *     bool_expr=boolExpression
	 */
	protected void sequence_where_clause(ISerializationContext context, where_clause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SQLPackage.Literals.WHERE_CLAUSE__BOOL_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SQLPackage.Literals.WHERE_CLAUSE__BOOL_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhere_clauseAccess().getBool_exprBoolExpressionParserRuleCall_1_0(), semanticObject.getBool_expr());
		feeder.finish();
	}
	
	
}
